#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
self_file =
  if File.symlink?(__FILE__)
    require 'pathname'
    Pathname.new(__FILE__).realpath
  else
    __FILE__
  end
$:.unshift(File.dirname(self_file) + "/../lib")

require 'torrentsync'
require 'haml'
require 'sinatra'
require 'bencode'
require 'ipaddr'
require 'nkf'
require 'shellwords'
require 'fileutils'
require 'digest/sha1'

TORRENTSYNC_HOME = File.dirname(__FILE__) + '/../'
set :public, TORRENTSYNC_HOME + 'public'
set :views, TORRENTSYNC_HOME + 'views'

enable :sessions

helpers do

  include Rack::Utils; alias_method :h, :escape_html
  def partial(template, options = {})
    options = options.merge({:layout => false})
    template = "_#{template.to_s}".to_sym
    haml(template, options)
  end

end

CONTENT_TYPES = {
    :html => 'text/html',
    :css => 'text/css',
    :js => 'application/javascript',
    :yaml => 'text/yaml',
    :txt => 'text/plain',
    }

before do
  request_uri = case request.env['REQUEST_URI']
    when /\.css$/ : :css
    when /\.js$/ : :js
    when /\.yaml$/ : :txt
    when /\.txt$/ : :txt
    else :html
  end
  content_type CONTENT_TYPES[request_uri], :charset => 'utf-8'
  response.headers['Cache-Control'] = 'no-cache'
end

get '/' do
  peers = get_peers
  torrents, status = get_torrents(peers)
  haml :index, :locals => {
      :peers => peers, :torrents => torrents, :status => status }
end

get '/t/:infohash' do
  peers = get_peers
  torrents, status = get_torrents(peers)
  infohash = params[:infohash]
  t = torrents[infohash]
  haml :torrent, :locals => { :infohash => infohash, :peers => peers,
      :torrents => torrents, :status => status }
end

get '/r/:infohash' do
  peers = get_peers
  torrents, status = get_torrents(peers)
  infohash = params[:infohash]
  rep = params[:rep].to_i
  t = torrents[infohash]
  sync_torrent(peers, t, infohash, rep)
  redirect "/t/#{infohash}"
end

get '/upload' do
  haml :upload
end

post '/upload' do
  download = SETTING['local']['download']
  torrents = SETTING['local']['torrents']
  f = params[:file]
  announce = params[:tracker]
  priv = !params[:private].nil?
  redirect '/upload' if f.nil? # TODO error
  path = f[:tempfile].path
  origname = f[:filename]
  origname = NKF.nkf("-w", origname) # TODO i18n
  name = origname.tr(" ", "_")
  name = Shellwords.escape(name)
  dest = "#{download}/#{name}"
  redirect '/upload' if File.exist?(dest) # TODO error
  FileUtils.mv(path, dest)
  torrent_piece_size = 2 ** 18
  torrent_pieces = []
  piece = ''
  File.open(dest, 'rb') do |fd|
    loop do
      data = fd.read(torrent_piece_size - piece.size)
      break if data.nil?
      piece << data
      if piece.size == torrent_piece_size
        torrent_pieces << Digest::SHA1.digest(piece)
        piece = ''
      end
    end
  end
  if piece.size > 0
    torrent_pieces << Digest::SHA1.digest(piece)
  end
  torrent = {
    'announce' => announce,
    'created by' => 'torrentsync 0.0.0',
    'creation date' => Time.now.to_i,
    'info' => {
      'length' => torrent_piece_size * (torrent_pieces.size - 1) + piece.size,
      'name' => origname,
      'private' => priv ? 1 : 0,
      'pieces' => torrent_pieces.join,
      'piece length' => torrent_piece_size,
    }
  }
  File.open("#{torrents}/#{name}.torrent", "wb") do |fd|
    fd.write(BEncode.dump(torrent))
  end
  # TODO push torrent and data
  redirect '/upload' # TODO success
end

get '/announce' do
  compact = params[:compact] == '1' # TODO support compact only
  peers = get_peers.map do |v|
    host = v[1]
    port = v[2].to_i
    ip = begin
      IPAddr.new(host)
    rescue
      IPAddr.new(Socket::getaddrinfo(host, nil)[0][3])
    end
    [ip.to_i, port].pack('Nn')
  end
  BEncode.dump({ 'interval' => 1 * 60, 'peers' => peers.join })
end

get '/scrape' do
  info_hash = params[:info_hash]
  BEncode.dump({ 'files' => {
    info_hash => { 'complete' => 1, 'downloaded' => 0, 'incomplete' => 0 }
  }})
end
