#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
self_file =
  if File.symlink?(__FILE__)
    require 'pathname'
    Pathname.new(__FILE__).realpath
  else
    __FILE__
  end
$:.unshift(File.dirname(self_file) + "/../lib")

require 'torrentsync'
require 'choice'

Choice.options do
  option :list do
    short '-l'
  end
  option :sync do
    short '-s'
  end
  option :dryrun do
    short '-n'
  end
  option :remove do
    short '-r'
  end
  option :purge do
    short '-p'
  end
end

c = Choice.choices
if c.list
  peers = get_peers
  torrents, status = get_torrents(peers)
  torrents.each do |hash, t|
    name = t[:name]
    total = t[:peers].inject(0.0){|v,h|v + h[1]}
    puts "%s %d(%3d%%) %11d %s" % [hash, t[:peers].size, (total * 100).to_i,
        t[:size], name]
  end
elsif c.sync
  rep = c.sync.nil? ? 2 : c.sync.to_i
  peers = get_peers
  torrents, status = get_torrents(peers)
  dead_peers = status.select{|k,v| v == :dead}.map(&:first)
  sync_torrents(peers - dead_peers, torrents, rep, c.dryrun)
elsif c.remove || c.purge
  purge = c.purge
  id = c.remove || purge
  purge = !purge.nil?
  peers = get_peers
  torrents, status = get_torrents(peers)
  t = torrents[id]
  unless t
    puts 'not found'
    exit 1
  end
  hps = t[:peers].map{|hp| host, port = hp[0].split(':'); [host, port.to_i]}
  haves = peers.select do |peer|
    hps.any?{|hp| peer[1] == hp[0] && peer[2] == hp[1]}
  end
  haves.each do |peer|
    type = peer[0]
    host, port, user, pass = peer[1], peer[2].to_i, peer[3], peer[4]
    peer = type2class(type).new(host, port, user, pass)
    puts "remove torrent from #{host}:#{port}"
    begin
      peer.remove(id, purge) unless c.dryrun
    rescue
    end
  end
end
